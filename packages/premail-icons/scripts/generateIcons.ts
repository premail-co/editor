#!/usr/bin/env node
import yargs from "yargs/yargs";
import { promises } from "fs";
import * as pjson from "../package.json";
import path, { resolve } from "path";
import { pascalCase } from "pascal-case";
const iconsDir = resolve(__dirname, "../icons");
import { format } from "prettier";
import { createServiceLogger } from "@premail/logger";

const argv = yargs(process.argv.slice(2)).options({
  iconVersion: {
    type: "string",
    demandOption: true,
    default: pjson.version,
  },
}).argv;
const isError = (err: unknown): err is Error => err instanceof Error;

interface IGenEntry {
  name: string;
  path: string;
  info?: string;
}

interface IGenFile {
  icons: IGenEntry[];
}

const logger = createServiceLogger(pjson.name);
const main = async () => {
  logger.info(`Reading args`);

  const args = await argv;
  const resolvedIconsFolder = path.resolve(`${iconsDir}/${args.iconVersion}`);
  const resolvedIconConfigFile = path.resolve(
    `${resolvedIconsFolder}/gen.json`
  );

  logger.info(
    `Creating icon package version ${args.iconVersion}, reading folder ${resolvedIconsFolder}`
  );
  logger.info(`Looking up gen.json file`);

  await promises.access(resolvedIconConfigFile);
  logger.info(`Reading and parsing gen.json file`);
  const buffer = await promises.readFile(resolvedIconConfigFile);
  const parsedContents: any = JSON.parse(buffer.toString());

  if (
    typeof parsedContents === "object" &&
    !Array.isArray(parsedContents) &&
    parsedContents !== null &&
    Array.isArray(parsedContents.icons) &&
    parsedContents.icons.every((entry: any) => entry.name && entry.path)
  ) {
    logger.info(`parsed gen.json contents`);
    const genFile: IGenFile = parsedContents;

    let indexContents = "/** AUTOGENERATED FILE DO NOT EDIT **/";

    for (const entry of genFile.icons) {
      const componentName = pascalCase(entry.name);

      logger.info(`Generating icon ${entry.name}`);
      const iconSVGPath = path.resolve(resolvedIconsFolder, entry.path);
      const componentPath = path.resolve(
        __dirname,
        `../src/generated/${componentName}`
      );
      const writableSVGPath = path.resolve(
        __dirname,
        `${componentPath}/${componentName}.svg`
      );

      const writableComponentPath = path.resolve(
        __dirname,
        `${componentPath}/${componentName}.tsx`
      );
      const writableStorybookPath = path.resolve(
        __dirname,
        `${componentPath}/${componentName}.storybook.tsx`
      );
      const writableJestPath = path.resolve(
        __dirname,
        `${componentPath}/${componentName}.test.tsx`
      );
      await promises.access(iconSVGPath);
      await promises.mkdir(componentPath, { recursive: true });
      const reactComponentContents = `
        /** AUTOGENERATED FILE DO NOT EDIT **/
        import React from "react";
        import { IPremailIconProps } from "../../types/index.js";
        import Icon from "./${componentName}.svg";
        
        interface I${componentName}Props extends IPremailIconProps {}
        
        /** ${entry.info} */
        const ${componentName} = React.forwardRef<SVGSVGElement, I${componentName}Props>((props, ref) => {
          const { size, ...rest } = props;
          return <Icon ref={ref} width={size} height={size} {...rest} />;
        });
        
        ${componentName}.defaultProps = {
          size: 24,
          color: "#000000",
          fill: "currentColor",
        };
        
        export { ${componentName} };
        export type { I${componentName}Props };
        `;

      const storybookContents = `
        /** AUTOGENERATED FILE DO NOT EDIT **/
        import { ComponentStory } from "@storybook/react";
        import React from "react";
        import { ${componentName} } from "./${componentName}";
        import { ComponentMeta } from "@storybook/react";
        
        export default {
          title: "${componentName}",
          component: ${componentName},
        } as ComponentMeta<typeof ${componentName}>;
        
        const Template: ComponentStory<typeof ${componentName}> = (props) => {
          return (
            <div
              style={{
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                background: "inherit",
              }}
            >
              <div
                style={{
                  boxSizing: "border-box",
                  padding: "40px 50px",
                  background: "inherit",
                  border: "1px solid #9EA19C",
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                  justifyContent: "center",
                }}
              >
                <div
                  style={{
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                  }}
                >
                  <${componentName} {...props} />
                  <h3 style={{ fontFamily: "Open sans", color: props.color }}>
                    ${entry.name} icon
                  </h3>
                </div>
                <span style={{ fontFamily: "Open sans", color: props.color }}>
                  ${entry.info}
                </span>
              </div>
            </div>
          );
        };
        
        export const Overview = Template.bind({});
        
        Overview.args = {
          size: 60,
          color: "#000000",
        };
    
        

        `;

      const jestContents = `
      /** AUTOGENERATED FILE DO NOT EDIT **/
      import React from "react";
      import { act } from "react-dom/test-utils";
      import ReactDOM from "react-dom/client";
      import { ${componentName} } from "./${componentName}";

      describe("${componentName} tests", () => {
        let container: HTMLElement | null = document.createElement("div");
        let root: ReactDOM.Root | null = null;

        beforeEach(() => {
          const newContainer = document.createElement("div");
          document.body.appendChild(newContainer);
          act(() => {
            root = ReactDOM.createRoot(newContainer);
          });
          container = newContainer;
        });

        afterEach(() => {
          if (container == null || root == null) return;
          act(() => {
            if (root == null) return;
            root.unmount();
          });
          document.body.removeChild(container);
          container = null;
        });

        it("Should render with specified size and color", () => {
          if (!container || !root) fail();
          const testSize = 100;
          const testColor = "#ff0000";
          const testId = "Icon";
          act(() => {
            root?.render(
              <${componentName} size={testSize} color={testColor} data-testid={testId} />
            );
          });
          const renderedElement = container.querySelector<SVGElement>(
            \`[data-testid=\${testId}]\`
          );

          if (!renderedElement) fail();

          expect(renderedElement.getAttribute("color")).toBe(testColor);
          expect(renderedElement.getAttribute("width")).toBe(testSize.toString());
          expect(renderedElement.getAttribute("height")).toBe(testSize.toString());
        });

        it("Should override size if width and/or height are specified", () => {
          if (!container || !root) fail();
          const testSize = 100;
          const width = 50;
          const height = 10;
          const testColor = "#ff0000";
          const testId = "Icon";
          expect(testSize).not.toBe(width);
          expect(testSize).not.toBe(height);

          act(() => {
            root?.render(
              <${componentName}
                size={testSize}
                color={testColor}
                data-testid={testId}
                width={width}
                height={height}
              />
            );
          });
          const renderedElement = container.querySelector<SVGElement>(
            \`[data-testid=\${testId}]\`
          );

          if (!renderedElement) fail();

          expect(renderedElement.getAttribute("color")).toBe(testColor);
          expect(renderedElement.getAttribute("width")).toBe(width.toString());
          expect(renderedElement.getAttribute("height")).toBe(height.toString());
          expect(renderedElement.getAttribute("width")).not.toBe(testSize.toString());
          expect(renderedElement.getAttribute("height")).not.toBe(
            testSize.toString()
          );
        });
      });

      `;
      //TODO: move file create component
      await promises.cp(iconSVGPath, writableSVGPath);
      await promises.writeFile(
        writableComponentPath,
        format(reactComponentContents, { parser: "typescript" })
      );
      await promises.writeFile(
        writableStorybookPath,
        format(storybookContents, { parser: "typescript" })
      );

      await promises.writeFile(
        writableJestPath,
        format(jestContents, { parser: "typescript" })
      );

      indexContents += `
        
        export * from "./${componentName}/${componentName}";
        `;
    }
    logger.info(`Generating index file`);

    const writableIndexPath = path.resolve(
      __dirname,
      `../src/generated/index.ts`
    );
    await promises.writeFile(
      writableIndexPath,
      format(indexContents, { parser: "typescript" })
    );
  } else {
    throw new Error(`Unexpected gen.json format`);
  }
};

main()
  .then(() => {
    logger.info(`Success`);
  })
  .catch((e) => {
    logger.error(`Script failed`);

    if (isError(e)) {
      logger.error(e.message);
      logger.error(e.stack);
    }
  });
